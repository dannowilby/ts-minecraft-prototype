
import { ExampleState } from "./index";
import { getBlock } from "./chunk";
import { Matrix4, Vector3 } from "@math.gl/core";
import { System } from "../engine/state";
import { Camera, createCamera } from '../engine/freeCamera';

export interface SelectionBox {

  program: WebGLProgram;
  vao: WebGLVertexArrayObject;
  vertexCount: number;
  model: Matrix4;

};

export interface Player extends Camera {
  rayStep: number;
  rayMaxLength: number;
  selectionBox: SelectionBox;
};

export const createPlayer = (gl: WebGL2RenderingContext) => ({ 
      rayStep: 0.1,
      rayMaxLength: 5,
      ...createCamera(gl),
})

export interface RayCastHit {
  position: Vector3;
  previous: Vector3;
};


export const renderSelectionBox = (gl:WebGL2RenderingContext, state: ExampleState) => {

    const { program, vao, vertexCount, model: modelMatrix } = state.player.selectionBox;
    const { projection: projectionMatrix, view: viewMatrix } = state.player;

    gl.useProgram(program);

    const projection = gl.getUniformLocation(program, "projection");
    const view = gl.getUniformLocation(program, "view");
    const model = gl.getUniformLocation(program, "model");

    gl.uniformMatrix4fv(projection, false, projectionMatrix);
    gl.uniformMatrix4fv(view, false, viewMatrix);
    gl.uniformMatrix4fv(model, false, modelMatrix);

    gl.bindVertexArray(vao);
    gl.drawArrays(gl.LINES, 0, vertexCount);
}

export const rayCast = (gl: WebGL2RenderingContext, state: ExampleState, pos: Vector3, dir: Vector3, rayStep: number, rayMaxLength: number): RayCastHit | null => {

  let ray = new Vector3(pos.x, pos.y, pos.z);

  const step = new Vector3(rayStep * dir.x, rayStep * dir.y, rayStep * dir.z);

  const numSteps = rayMaxLength / rayStep;

  for(let i = 0; i < numSteps; i++) {

    const previous = new Vector3(ray.x, ray.y, ray.z);

    ray.x += step[0];
    if(getBlock(state, ray) != 0)
        return {
          position: ray,
          previous: previous,
        };
    previous.x += step[0];

    ray.y += step[1];
    if(getBlock(state, ray) != 0)
        return {
          position: ray,
          previous: previous,
        };
    previous.y += step[1];

    ray.z += step[2];
    if(getBlock(state, ray) != 0)
        return {
          position: ray,
          previous: previous,
        };

  }

  return null;
}
